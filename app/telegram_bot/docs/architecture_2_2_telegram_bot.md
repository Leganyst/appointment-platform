# Архитектурные решения (Telegram‑бот)

Данный раздел описывает архитектуру части системы, реализованной в виде Telegram-бота (модуль `app/telegram_bot`), и её взаимодействие с core‑сервисами платформы записи на приём.

## Выбор типа архитектуры

**В составе платформы** Telegram‑бот является отдельным сервисом‑адаптером (edge/adapter), который предоставляет пользовательский интерфейс в Telegram и обращается к core‑части по RPC. В терминах общей архитектуры продукта это **микросервисный** подход: бот разворачивается и масштабируется независимо от core‑сервисов, при этом сам хранит минимум доменных данных.

**Внутри компонента бота** используется модульный «мини‑монолит»: один процесс Python с четким разделением по слоям (handlers → services → интеграции/DTO). Обработка входящих событий построена в **асинхронной событийной модели** (aiogram 3.x), запуск — через **long polling** (без публичного веб‑хука).

**Клиент‑серверная модель взаимодействия**:
- Telegram Bot API ↔ сервис Telegram‑бота (обмен апдейтами и ответами).
- Telegram‑бот ↔ core‑сервисы `Identity` и `Calendar` по **gRPC** (protobuf контракты в `api/proto/*`).

## Используемые технологии и подходы

- **Язык/рантайм:** Python (asyncio).
- **UI/транспорт Telegram:** `aiogram` 3.x (роутеры, фильтры, FSM).
- **Межсервисное взаимодействие:** `grpcio` (асинхронные gRPC‑клиенты), protobuf‑контракты (`src/telegram_bot/generated/*`).
- **Конфигурация:** переменные окружения (`src/telegram_bot/config.py`), в т.ч. endpoints core‑сервисов и deadlines.
- **Хранение технических данных (опционально):** PostgreSQL + SQLAlchemy 2.x (sync) + `psycopg2` (`src/telegram_bot/models/*`, `src/telegram_bot/db/*`). В текущем запуске основной сценарий опирается на FSM‑контекст aiogram, а доменные данные (профиль, слоты, бронирования) — в core.
- **Трассировка запросов:** correlation id (`x-corr-id`) прокидывается в gRPC metadata (`src/telegram_bot/services/grpc_clients.py`, `src/telegram_bot/utils/corr.py`).

## Структура слоёв

### Слой представления (Presentation)

Отвечает за прием апдейтов Telegram, маршрутизацию и формирование ответов пользователю.

- Роутеры и обработчики команд/сообщений/коллбеков: `src/telegram_bot/handlers/*`
  - `/start` и первичная идентификация: `src/telegram_bot/handlers/start.py`
  - выбор роли и сбор профиля: `src/telegram_bot/handlers/role.py`
  - клиентский сценарий (поиск услуг/слотов, бронирование, отмена): `src/telegram_bot/handlers/client_flow.py`
  - сценарии представителя (расписание, слоты, подтверждение): `src/telegram_bot/handlers/provider_flow.py`
- FSM‑состояния диалогов: `src/telegram_bot/states.py` и документы состояний: `docs/state_machine.md`, `docs/provider_flow.md`.
- Формирование клавиатур/CTA: `src/telegram_bot/keyboards.py`.

### Слой бизнес‑логики (Application/Use Cases)

Содержит прикладные операции, которыми пользуются обработчики, и правила оркестрации вызовов core‑сервисов.

- Сценарии работы с календарём/записями: `src/telegram_bot/services/calendar.py`.
- Идентификация и профили: `src/telegram_bot/services/identity.py`.
- Нормализация ошибок для UI: `src/telegram_bot/services/errors.py`.

Важно: ключевые доменные правила (например, «слот свободен/занят», «проверка доступности», «подтверждение брони») находятся в core‑сервисах; бот выполняет роль UI‑оркестратора и клиента.

### Слой доступа к данным и интеграций (Data Access/Integration)

Инкапсулирует протоколы, клиенты и (при необходимости) локальное хранилище технических данных.

- gRPC‑каналы и stubs: `src/telegram_bot/services/grpc_clients.py`, `src/telegram_bot/generated/*`.
- Контракты сервисов (source of truth): `api/proto/*.proto`.
- Локальная БД (технические таблицы/кэш/аудит): `src/telegram_bot/db/*`, `src/telegram_bot/models/*`.

## Подход к отказоустойчивости и восстановлению

### Обработка сбоев внешних зависимостей

- **Ограничение времени ожидания**: для вызовов core‑сервисов используется deadline (`GRPC_DEADLINE_SEC`) и обработка `DEADLINE_EXCEEDED`/`UNAVAILABLE` с понятным сообщением пользователю (`src/telegram_bot/services/errors.py`).
- **Деградация функциональности**: при недоступности `Identity`/`Calendar` бот возвращает сообщение об ошибке и предлагает повторить действие позже; критичные операции не выполняются «в обход» core.
- **Трассировка**: correlation id прокидывается в каждый gRPC‑запрос, что упрощает поиск цепочек ошибок в логах разных компонентов.

### Восстановление работоспособности бота

- **Статусность**: бот не хранит критичные доменные данные локально; источником истины являются core‑сервисы, поэтому перезапуск бота не приводит к потере записей/слотов.
- **FSM‑контекст**: состояние диалога хранится в памяти (MemoryStorage). При рестарте активный диалог может быть потерян, но сценарии восстанавливаются через повторный вход (`/start`) и повтор действий.
- **Жизненный цикл ресурсов**: при завершении работы корректно закрываются HTTP‑сессия бота и gRPC‑каналы (`src/telegram_bot/main.py`).

### Рекомендации для повышения отказоустойчивости (эволюционный путь)

При необходимости high‑availability и масштабирования:
- заменить MemoryStorage на внешний стор (например, Redis) для сохранения FSM между рестартами/репликами;
- внедрить retries с backoff для idempotent‑операций чтения (list/find) и circuit breaker для деградации при массовых сбоях core;
- перейти с long polling на webhook (или обеспечить single‑leader polling), если требуется несколько реплик бота.
