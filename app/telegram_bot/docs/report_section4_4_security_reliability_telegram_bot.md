# Безопасность и надёжность (Telegram‑бот)

Раздел описывает фактические механизмы защиты, аутентификации/авторизации и надежности для компонента `app/telegram_bot`, а также практики резервного копирования и восстановления, применимые к текущей реализации.

## Защита данных и шифрование

### Каналы передачи данных

1) **Клиент Telegram ↔ Telegram‑бот**
- Пользователь взаимодействует с ботом через Telegram‑клиент.
- Передача сообщений и callback‑событий осуществляется через инфраструктуру Telegram, которая использует защищённые каналы (HTTPS/TLS) на своей стороне.

2) **Telegram‑бот ↔ core‑сервисы (Identity/Calendar)**
- Взаимодействие реализовано по **gRPC** (`grpc.aio`) с использованием protobuf‑контрактов (`api/proto/*.proto`).
- По умолчанию используется **нешифрованный канал** (`grpc.aio.insecure_channel`) — это зафиксировано в `src/telegram_bot/services/grpc_clients.py`.
- Поддерживается включение **TLS**:
  - `GRPC_TLS=true` — использовать `grpc.aio.secure_channel`;
  - `GRPC_ROOT_CERT` — путь к root CA сертификату для валидации сервера (загрузка файла реализована в `src/telegram_bot/services/grpc_clients.py`).

Итог: шифрование на сегменте «бот ↔ core» в текущей реализации **конфигурируемое** и зависит от переменных окружения.

### Хранение секретов и конфигурации

- Секреты (например, `BOT_TOKEN`) и адреса сервисов задаются через переменные окружения (`src/telegram_bot/config.py`).
- В репозитории присутствует пример конфигурации `.env.example`; рабочие значения не должны храниться в VCS.

### Минимизация и обработка данных

- Идентификация пользователя производится по **Telegram ID** (передаётся в `IdentityService.RegisterUser`), в боте не хранится пароль/токен пользователя.
- В FSM‑контексте aiogram (оперативная память процесса) сохраняются значения, необходимые для диалога: `role`, `client_id/provider_id`, `contact_phone`, выбранные `service/provider/slot` и кэши для UI.
- Персистентного хранилища PII в боте по основному сценарию нет; источником истины по профилю и контактам является `Identity` сервис.

## Аутентификация и авторизация

### Аутентификация

- Пользователь «аутентифицируется» через факт обращения из своего Telegram‑аккаунта: бот получает `message.from_user.id` и передаёт его в `IdentityService.RegisterUser` (`src/telegram_bot/handlers/start.py`).
- Логины/пароли на стороне Telegram‑бота **не используются**.
- Двухфакторная аутентификация в Telegram‑боте **не реализуется**, так как компонент не управляет учетными данными пользователя; 2FA возможна на уровне Telegram‑аккаунта пользователя (вне системы).

### Авторизация (модель ролей)

- Роль пользователя хранится и управляется в core‑сервисе `Identity` (`role_code`).
- Бот запрашивает/обновляет роль через `IdentityService.SetRole`, а затем показывает соответствующие меню/ветки сценариев (`src/telegram_bot/handlers/role.py`).
- Внутри бота ограничения реализуются как **разветвление UI/сценариев** (какую клавиатуру показать, какие шаги выполнить).
- Доменные ограничения (например, “кто может подтверждать/создавать слоты”) должны обеспечиваться core‑сервисами через свои правила и проверки, так как бот является клиентом API.

## Надёжность и отказоустойчивость

### Обработка ошибок и таймауты

- Для gRPC вызовов используется deadline `GRPC_DEADLINE_SEC` (`src/telegram_bot/config.py`) и передаётся в каждый вызов (см. обработчики в `src/telegram_bot/handlers/*`).
- Типовые ошибки gRPC преобразуются в понятные сообщения пользователю (`src/telegram_bot/services/errors.py`), в т.ч.:
  - `UNAVAILABLE`, `DEADLINE_EXCEEDED` → “Сервис временно недоступен, попробуйте позже.”
  - `FAILED_PRECONDITION` → “Слот недоступен или занят.”

### Трассировка и диагностика

- Для каждого запроса генерируется correlation id (`src/telegram_bot/utils/corr.py`) и передается в metadata `x-corr-id` (`src/telegram_bot/services/grpc_clients.py`), что упрощает сквозной поиск по логам бота и core‑сервисов.

### Хранение состояния диалога и восстановление

- FSM‑состояние хранится в памяти процесса (`MemoryStorage`, `src/telegram_bot/bot.py`).
- Следствие: при перезапуске бота состояние текущих диалогов теряется; пользователь может продолжить работу через повторный вход (`/start`) и повтор действий.
- Критичные доменные данные (слоты, бронирования, профили) хранятся в core‑сервисах, поэтому перезапуск бота не приводит к потере записей.

### Рекомендации для повышения надежности (без изменения бизнес‑логики)

- Перенести FSM storage в внешний стор (Redis) для сохранения состояния между рестартами/репликами.
- Включить TLS для gRPC и ограничить сетевой доступ (network policy/ACL) между ботом и core.
- Для операций чтения (каталог/поиск слотов) добавить ретраи с backoff на уровне клиента (с учётом idempotency), если это допускается политиками проекта.

## Резервирование, бэкапы и аварийное восстановление

### Что подлежит резервированию

1) **Core‑данные (основной приоритет)**
- Профили пользователей/роли/контакты (Identity).
- Слоты, расписания и бронирования (Calendar).
Эти данные не хранятся в Telegram‑боте и должны бэкапиться на стороне core‑инфраструктуры (обычно БД core‑сервисов).

2) **Конфигурация и секреты Telegram‑бота**
- `BOT_TOKEN`, адреса сервисов (`*_GRPC_ENDPOINT`), параметры TLS (`GRPC_TLS`, `GRPC_ROOT_CERT`), deadline (`GRPC_DEADLINE_SEC`).
Рекомендуемое хранение: секрет‑хранилище/CI‑variables/конфигурационный менеджер, с возможностью восстановления версий.

3) **Локальная БД Telegram‑бота (если используется)**
- В проекте присутствуют модули `src/telegram_bot/db/*` и `src/telegram_bot/models/*` (PostgreSQL/SQLAlchemy), но в текущем запуске сессия БД не инициализируется в `src/telegram_bot/main.py` (session_factory передается как `None`).
- Если локальная БД будет подключена (например, для кэша/аудита), её резервирование выполняется стандартными средствами PostgreSQL (pg_dump/replication/backups).

### Процедура восстановления (уровень компонента бота)

- Восстановить конфигурацию/секреты (в т.ч. `BOT_TOKEN`, TLS сертификаты при включённом TLS).
- Развернуть сервис Telegram‑бота (контейнер/systemd) с корректными переменными окружения.
- Проверить доступность core‑сервисов по указанным endpoints.
- При ошибках связи бот будет деградировать с пользовательскими сообщениями; полноценная работоспособность зависит от восстановления core‑данных (БД/сервисов).
