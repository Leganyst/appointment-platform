# Руководство пользователя — сервис `core`

Документ описывает, как пользоваться возможностями платформы записи через внешний клиент (например, Telegram‑бот), который обращается к gRPC‑сервису `core`. Сам `core` не имеет UI и не запрашивает логин/пароль: он предоставляет API для регистрации по Telegram ID и операций календаря (слоты/бронирования/каталог услуг).

## 1. Назначение сервиса

`core` обеспечивает:
- идентификацию пользователя по `telegram_id` и выдачу связанных внутренних идентификаторов (`client_id`, `provider_id`);
- каталог услуг;
- получение свободных слотов и “быстрые предикаты” для подсказок;
- создание/отмену бронирований;
- управление расписаниями провайдера и слотами (для роли `provider`);
- массовую отмену слотов провайдера с возвратом получателей уведомлений.

## 2. Роли и сущности (как это работает)

### 2.1 Пользователь, клиент, провайдер

- **User** — запись пользователя, ключевой внешний идентификатор: `telegram_id`.
- **Client** — сущность “клиент” для бронирований. Создаётся автоматически при регистрации, чтобы любой пользователь мог записываться.
- **Provider** — сущность “провайдер/мастер”. Создаётся при назначении роли `provider` (или при поиске по телефону для согласования данных).

### 2.2 Роли

- В системе хранится одна роль на пользователя (policy “single role”).
- Для действий провайдера (управление расписаниями/слотами и массовые отмены) требуется роль `provider`.

## 3. Типовые сценарии (что делает пользователь)

Ниже описаны сценарии на уровне поведения внешнего клиента. Реальные кнопки/экраны зависят от UI (бот/панель), но функционально опираются на одни и те же шаги.

### 3.1 Первое взаимодействие / регистрация

Цель: “завести” пользователя в системе и получить идентификаторы `client_id` (для записей) и, при необходимости, `provider_id`.

Шаги:
1) Клиент (бот) вызывает `IdentityService.RegisterUser` с `telegram_id`, `display_name`, `username`, `contact_phone` (если есть).
2) Сервис создаёт/обновляет `users` и гарантирует запись `clients`.
3) Клиент получает в ответе:
   - `user.id` — внутренний UUID пользователя,
   - `user.client_id` — UUID клиента (нужен для бронирований),
   - `user.provider_id` — UUID провайдера (если роль/сущность уже есть),
   - `user.role_code` — текущая роль (может быть пустой).

### 3.2 Выбор услуги (каталог)

Цель: выбрать услугу из публичного каталога.

Шаги:
1) Внешний клиент вызывает `CalendarService.ListServices` (обычно `only_active=true`).
2) Пользователь выбирает услугу, UI запоминает `service_id`.

Примечания:
- `default_duration_min` может быть `0`, если длительность не задана.

### 3.3 Поиск свободного времени (слоты)

Цель: показать пользователю доступные варианты записи.

Основной способ:
1) Клиент вызывает `CalendarService.ListFreeSlots`:
   - `provider_id` обязателен;
   - `service_id` опционален (если фильтрация по услуге нужна);
   - `start`/`end` — окно времени;
   - `page`/`page_size` — пагинация.
2) UI отображает список слотов и позволяет выбрать конкретный `slot_id`.

Быстрые подсказки (для UX):
- `GetNearestFreeSlot` — ближайший свободный слот от указанного времени.
- `GetNextProviderSlot` — следующий свободный слот конкретного провайдера от времени `from` (с ограничением `until`).
- `FindFreeSlots` — небольшая выдача свободных слотов в интервале без пагинации (для “быстрых подсказок”).

### 3.4 Проверка доступности перед записью

Цель: убедиться, что слот ещё свободен и нет пересечений по времени.

Шаги:
1) Клиент вызывает `CalendarService.CheckAvailability(client_id, slot_id)`.
2) Если `available=false`, UI показывает `reason` и предлагает выбрать другой слот.

Что проверяется:
- слот существует и имеет статус “свободен”;
- у клиента нет пересекающихся подтверждённых бронирований;
- у провайдера нет пересекающихся подтверждённых бронирований.

### 3.5 Создание записи (бронирование)

Цель: закрепить выбранный слот за клиентом.

Шаги:
1) Клиент вызывает `CalendarService.CreateBooking(client_id, slot_id, comment)`.
2) Если операция успешна:
   - создаётся бронирование со статусом `confirmed`;
   - слот переводится в статус “занят”.
3) UI показывает детали бронирования (провайдер, услуга, время).

Возможные причины отказа:
- слот уже занят/отменён;
- конфликт по времени у клиента или провайдера;
- неверные идентификаторы.

### 3.6 Просмотр своих записей

Цель: показать список записей пользователя.

Шаги:
1) Клиент вызывает `CalendarService.ListBookings(client_id, from, to, page, page_size)`.
2) UI отображает бронирования и их статус.

Примечание: текущая реализация фильтрует по времени создания бронирования (`created_at`), а не по времени слота.

### 3.7 Отмена записи

Цель: отменить ранее созданное бронирование и освободить слот.

Шаги:
1) Клиент выбирает запись и вызывает `CalendarService.CancelBooking(booking_id, reason)`.
2) При успехе:
   - бронирование становится `cancelled` (заполняется `cancelled_at`);
   - слот снова становится “свободным”.

Примечание: поле `reason` в текущей реализации не сохраняется в БД при одиночной отмене (используется только при массовой отмене провайдером).

## 4. Сценарии провайдера (управление расписанием/слотами)

Эти сценарии доступны только для пользователей с ролью `provider` и должны быть защищены внешним клиентом (например, через gateway/бот с проверкой прав).

### 4.1 Назначение роли провайдера

1) Внешний клиент вызывает `IdentityService.SetRole(telegram_id, "provider")`.
2) Сервис назначает роль и создаёт сущность `providers`, если её нет.
3) В профиле появляется `provider_id`.

### 4.2 Управление расписаниями (правила повторений)

Возможности:
- `ListProviderSchedules(provider_id)` — список правил.
- `CreateProviderSchedule(provider_id, schedule)` — создать правило.
- `UpdateProviderSchedule(schedule_id, schedule)` — обновить правило (нельзя менять владельца).
- `DeleteProviderSchedule(schedule_id)` — удалить правило.
- `ExpandSchedule(schedule_id, window_start, window_end)` — предпросмотр развёрнутых интервалов в окне.

Как это влияет на слоты:
- слоты из правил материализуются “лениво” при запросах свободных слотов в окне, а не создаются сразу “навсегда”.

### 4.3 Управление слотами (точечные изменения)

- `CreateSlot(provider_id, service_id, range)` — добавить слот.
- `UpdateSlot(slot_id, service_id?, range?, status?)` — изменить параметры слота.
- `DeleteSlot(slot_id)` — удалить слот.

### 4.4 Массовая отмена слотов (для уведомлений)

Цель: отменить окно времени (например, болезнь/отпуск) и получить список клиентов для уведомления.

Шаги:
1) Провайдер вызывает `BulkCancelProviderSlots(provider_id, start, end, reason)`.
2) Сервис:
   - отменяет бронирования в этом окне (проставляет `cancelled_at`, записывает `reason` в комментарий);
   - отменяет слоты в окне;
   - возвращает список `AffectedBooking` с `client_telegram_id` — для внешнего уведомления.

## 5. Форматы и время

- В gRPC используются `google.protobuf.Timestamp`.
- Рекомендуется передавать времена в UTC и приводить отображение к локальному часовому поясу в UI.
- В правилах расписаний хранится `time_zone`, которая учитывается при развёртывании расписания в интервал слотов.

## 6. Частые ошибки и как их интерпретировать (на уровне пользователя)

- “slot is not free” — слот уже занят или отменён; выбрать другой.
- “client has conflicting booking” — у пользователя есть пересекающаяся запись; выбрать другой слот/время.
- “provider has conflicting booking” — слот пересекается с другой записью провайдера; выбрать другой.
- “provider not found / only providers can manage…” — доступ к провайдерским операциям не подтверждён; требуется роль `provider` и корректный `provider_id`.

## 7. Как поддержке диагностировать проблемы (коротко)

Минимальный чек‑лист диагностики:
1) Проверить доступность gRPC порта `50051` и что сервис запущен (логи старта, отсутствие panic).
2) Проверить подключение к БД:
   - корректность `DB_HOST/DB_PORT/DB_USER/DB_PASSWORD/DB_NAME`;
   - наличие расширения `pgcrypto` (для `gen_random_uuid()`).
3) Проверить API через reflection (если доступно в окружении):

```bash
grpcurl -plaintext localhost:50051 list
grpcurl -plaintext localhost:50051 list calendar.v1.CalendarService
grpcurl -plaintext localhost:50051 list identity.v1.IdentityService
```
